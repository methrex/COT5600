#%%
import numpy as np
import scipy.linalg as la
from scipy.linalg import svd

def nullspace(A, rcond=None):
    #I had some trouble importing and updating scipy, so I copied this function
    #from the scipy GitHub
    
    """
    Construct an orthonormal basis for the null space of A using SVD
    Parameters
    ----------
    A : (M, N) array_like
        Input array
    rcond : float, optional
        Relative condition number. Singular values ``s`` smaller than
        ``rcond * max(s)`` are considered zero.
        Default: floating point eps * max(M,N).
    Returns
    -------
    Z : (N, K) ndarray
        Orthonormal basis for the null space of A.
        K = dimension of effective null space, as determined by rcond
    See also
    --------
    svd : Singular value decomposition of a matrix
    orth : Matrix range
    Examples
    --------
    One-dimensional null space:
    >>> from scipy.linalg import null_space
    >>> A = np.array([[1, 1], [1, 1]])
    >>> ns = null_space(A)
    >>> ns * np.sign(ns[0,0])  # Remove the sign ambiguity of the vector
    array([[ 0.70710678],
           [-0.70710678]])
    Two-dimensional null space:
    >>> B = np.random.rand(3, 5)
    >>> Z = null_space(B)
    >>> Z.shape
    (5, 2)
    >>> np.allclose(B.dot(Z), 0)
    True
    The basis vectors are orthonormal (up to rounding error):
    >>> Z.T.dot(Z)
    array([[  1.00000000e+00,   6.92087741e-17],
           [  6.92087741e-17,   1.00000000e+00]])
    """
    u, s, vh = svd(A, full_matrices=True)
    M, N = u.shape[0], vh.shape[1]
    if rcond is None:
        rcond = np.finfo(s.dtype).eps * max(M, N)
    tol = np.amax(s) * rcond
    num = np.sum(s > tol, dtype=int)
    Q = vh[num:,:].T.conj()
    return Q

#%%
def vec(A):
    #Vectorizes a matrix A, column by column
    v=[]
    N=A.shape[0]
    for i in range(N):
        for k in range(N):
            v.append(A[k][i])
    return v

#%%
def annihilate_poly(M,n):
    #takes as input a square matrix M of size N x N
    #
    #returns an array whose elements are the coefficients of a polynomial of
    #degree n that annihilates the matrix M. There may be multiple vectors in
    #the null space of the matrix, such as for the identity matrix, so we will
    #just choose the first one. 
    #
    #This is not necessarily the minimal polynomial of M! There may also not
    #exist a polynomial of this degree that annihilates M.
    
    N=M.shape[0]
        
    A=[]
    for k in range(n+1):
        if k==0:
            I=np.identity(N)
            A.append(vec(I))
        else:
            A.append(vec(M**(k)))
            
    A=np.transpose(A)
            
    NA=nullspace(np.asmatrix(A))    #cols of NA should send A to 0
    if NA.size ==0 :
        #polynomial of this degree does not exist
        return NA
    else:
        return NA
        
#%%
    
    M=np.array([[2,0,0],[0,2,0],[0,0,3]])
    
    def annihilate_min_deg_poly(M):
        #takes as input an N x N matrix M and iteratively finds the minimal
        #polynomial
        
        #check if zero-matrix
        
        #M^1, then M^1 and M^2, then ..... use above function^
        N=M.shape[0]
        
        if np.all(M-np.identity(N) ==0):
            print('You supplied the identity. Minimal polynomial is:')
            print('I-I=0')
            return[1,-1]
        elif np.all(M==0):
            print('You supplied the 0 matrix')
            return []
        
        for i in range(1,N+1):
    
            c=annihilate_poly(M,i)
            if c.size == 0:
                continue
            elif c.shape[1]==1:
                print('Minimal polynomial found!');print('');
                print('Degree: ',str(i))
                print('Coeffs are: ')
                print(c)
                return c
            else:
                print("There's a problem")
        
#%%
                annihilate_min_deg_poly(M)
                
